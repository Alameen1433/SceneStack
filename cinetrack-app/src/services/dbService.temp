import { openDB, type IDBPDatabase, type DBSchema } from "idb";
import type { WatchlistItem } from "../types";

const DB_NAME = "cinetrackDB";
const STORE_NAME = "watchlist";
const DB_VERSION = 1;

// Define a type for our database schema for better type safety
interface CineTrackDB extends DBSchema {
  [STORE_NAME]: {
    key: number;
    value: WatchlistItem;
    indexes: { tags: string };
  };
}

let dbPromise: Promise<IDBPDatabase<CineTrackDB>>;

const initDB = () => {
  if (!dbPromise) {
    dbPromise = openDB<CineTrackDB>(DB_NAME, DB_VERSION, {
      upgrade(db) {
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, { keyPath: "id" });
          // multiEntry allows indexing each item in an array, which is perfect for tags
          store.createIndex("tags", "tags", { multiEntry: true });
        }
      },
    });
  }
  return dbPromise;
};

export const getAllWatchlistItems = async (): Promise<WatchlistItem[]> => {
  const db = await initDB();
  return db.getAll(STORE_NAME);
};

export const getWatchlistItem = async (
  id: number
): Promise<WatchlistItem | undefined> => {
  const db = await initDB();
  return db.get(STORE_NAME, id);
};

export const putWatchlistItem = async (
  item: WatchlistItem
): Promise<number> => {
  const db = await initDB();
  return db.put(STORE_NAME, item);
};

export const deleteWatchlistItem = async (id: number): Promise<void> => {
  const db = await initDB();
  return db.delete(STORE_NAME, id);
};

export const clearAndBulkPut = async (
  items: WatchlistItem[]
): Promise<void> => {
  const db = await initDB();
  const tx = db.transaction(STORE_NAME, "readwrite");
  await Promise.all([
    tx.store.clear(),
    ...items.map((item) => tx.store.put(item)),
  ]);
  await tx.done;
};
